#include "mtl.h"

#include <cpr/cpr.h>
#include <json.hpp>

#include <iostream>
#include <regex>
#include <chrono>

static inline uint32_t
genXr(uint32_t const a, char const* b)
{
    auto len = strlen(b);
    auto r = a;
    for (uint32_t c=0, d=0; c < len-2; c += 3) {
        d = static_cast<uint32_t>(b[c+2]);
        d = ('a' <= d)      ? (d - 87) : (d - 48);
        d = ('+' == b[c+1]) ? (r >> d) : (r << d);
        r = ('+' == b[c])   ? (r + d)  : (r ^ d);
    }
    return r;
}

static std::string
genTk(std::string const& text)
{
    char const* s = text.c_str();
    auto const tp = std::chrono::system_clock::now().time_since_epoch();
    auto const hr = std::chrono::duration_cast<std::chrono::hours>(tp);
    auto const tkk = static_cast<uint32_t>(hr.count());
    uint32_t a = tkk;
    for (size_t i = 0; i < strlen(s); i++) {
        a = genXr(a + static_cast<uint8_t const>(s[i]), "+-a^+6");
    }
    a = genXr(a, "+-3^+b+-f") % 1'000'000;
    return std::to_string(a) + "." + std::to_string(a ^ tkk);
}

static int
parse(std::string const& text)
{
    // EXPL: fill empty array items with 'null' to obtain valid JSON.
    std::regex skipped_null(R"((,|\[)(?=,|\]))", std::regex::nosubs | std::regex::optimize);
    auto json_str = std::regex_replace(text, skipped_null, "$&null");
    auto json_dom = nlohmann::json::parse(json_str);
    std::cout << json_dom.dump(2) << std::endl;

    // 0 - original, translation, phonetics
    // 1 - word classes and explanations
    // 5 - alternative translations
    // 7 - autocorrection
    // 8 - identified source languages
    // 11 - (original) word classes and synonyms
    // 12 - (original) word classes and explanations
    // 13 - (original) examples
    // 14 - (original) see also

    return 0;
}

int google(std::string const& text, std::string const& sl, std::string const& tl)
{
    // auto const kAgent = "Mozilla/5.0 (Windows NT 6.1; rv:38.0) Gecko/20100101 Firefox/38.0";
    // "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko"
    auto const kAgent = "Mozilla/5.0 (X11; Linux x86_64) ";
    auto const kUrl = "http://translate.googleapis.com/translate_a/single";
    // ALT:(prev) "https://translate.google.com/translate_a/single";
    // ALT:(old)  "translate.google.com/translate_a/t";

    // NOTE: this 'tk' is different from generated by script
    // exec((std::string("./tk_hack.pl") + " '" + text + "'").c_str());
    auto const tk = genTk(text);

    auto params = cpr::Parameters{
        {"client", "gtx"}, {"ie", "UTF-8"}, {"oe", "UTF-8"}, {"dt", "t"},
        {"dt", "rm"},      {"dt", "at"},    {"sl", sl},      {"tl", tl},
        {"hl", tl},        {"tk", tk},      {"q", text}};

    // WTF: client: 't', {"otf", "1"}, {"ssel", "0"}, {"tsel", "0"}, {"kc", "7"},
    // Request:(dt=..)
    // at | examples table
    // bd | ?
    // ex | ?
    // ld | language detection
    // md | ?
    // qc | w/o autocorrecting (qca -- with)
    // rm | romanization (phonetics)
    // rw | ?
    // ss | ?
    // t  | translation + raw

    // DEV: return complete url on demand (to investigate)
    // std::cout << params.content << std::endl;

    cpr::Session session;
    session.SetUrl(kUrl);
    session.SetHeader({{"User-Agent", kAgent}});
    session.SetParameters(params);

    // DEV:(exceptions) bad_request, bad_network
    auto response = session.Get();

    // DEV:(exceptions) process ret code: 403, etc
    std::cout << response.text << std::endl;

    // DEV:(exceptions) std::invalid_argument -- wrong format
    parse(response.text);

    return 0;
}
